#!/bin/bash

# Script to recursively remove node_modules and venv directories
# Author: github.com/s-k-zaman
# Version: 2.3 (Fixed find command and path resolution bugs)

set -euo pipefail # Exit on error, undefined vars, pipe failures

# Default values
START_DIR="."
BATCH_MODE=false
DRY_RUN=false
CUSTOM_DIRS=()
DEFAULT_DIRS=("node_modules" "venv" ".venv" "__pycache__" ".pytest_cache")

# Colors
readonly NC='\033[0m'
readonly RED='\033[0;31m'
readonly GREEN='\033[0;32m'
readonly YELLOW='\033[1;33m'
readonly BLUE='\033[0;34m'

# Function to show help
show_help() {
    cat <<EOF
Node Modules & Virtual Environment Cleaner

DESCRIPTION:
    Recursively finds and removes common development directories that can be safely
    deleted and regenerated (node_modules, venv, __pycache__, etc.)

USAGE:
    $(basename "$0") [OPTIONS] [DIRECTORY]

ARGUMENTS:
    DIRECTORY           Starting directory to search (default: current working directory)

OPTIONS:
    -h, --help          Show this help message and exit
    -b, --batch         Run in batch mode (no confirmation required)
    -n, --dry-run       Show what would be deleted without actually deleting
    -d, --dirs DIRS     Comma-separated list of directory names to remove
                        (default: node_modules,venv,.venv,__pycache__,.pytest_cache)
    -v, --verbose       Enable verbose output

EXAMPLES:
    $(basename "$0")                                    # Interactive mode in current directory
    $(basename "$0") /path/to/project                   # Interactive mode in specific directory
    $(basename "$0") --batch ~/projects                 # Batch mode in ~/projects
    $(basename "$0") --dry-run .                        # See what would be deleted
    $(basename "$0") --dirs "node_modules,dist" .       # Only remove node_modules and dist
    $(basename "$0") -b -d "venv,.venv" ~/python-proj   # Batch remove only Python virtual envs

EXIT CODES:
    0    Success
    1    General error
    2    Invalid arguments
EOF
}

# Function to print colored output
print_info() {
    echo -e "${YELLOW}[INFO]${NC} $1"
}

print_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

print_error() {
    echo -e "${RED}[ERROR]${NC} $1" >&2
}

print_debug() {
    if [[ "${VERBOSE:-false}" == "true" ]]; then
        echo -e "${BLUE}[DEBUG]${NC} $1"
    fi
}

# Function to get a user-friendly display name for the starting directory
get_start_dir_display() {
    local resolved_path="$1"
    local original_input="${2:-}"
    
    # If user specified current directory explicitly (. or ./), or no directory (default)
    if [[ "$original_input" == "." || "$original_input" == "./" || -z "$original_input" ]]; then
        echo "current directory ($(basename "$resolved_path"))"
    else
        # For any other path, show the original user input
        echo "$original_input"
    fi
}

# Function to convert absolute path to relative path for file/directory display
get_relative_path() {
    local abs_path="$1"
    local base_path="$START_DIR"

    # Convert to absolute paths for comparison
    abs_path=$(realpath "$abs_path" 2>/dev/null || echo "$abs_path")
    base_path=$(realpath "$base_path" 2>/dev/null || echo "$base_path")

    # If the path is the same as the base path, show current directory indicator
    if [[ "$abs_path" == "$base_path" ]]; then
        echo "./$(basename "$base_path")"
    # If the path is under START_DIR, show relative path
    elif [[ "$abs_path" == "$base_path"* ]]; then
        local rel_path="${abs_path#$base_path}"
        rel_path="${rel_path#/}" # Remove leading slash
        if [[ -z "$rel_path" ]]; then
            echo "./$(basename "$base_path")"
        else
            echo "./$rel_path"
        fi
    else
        # For paths outside START_DIR, show absolute path
        echo "$abs_path"
    fi
}

# Function to parse command line arguments
parse_arguments() {
    while [[ $# -gt 0 ]]; do
        case $1 in
        -h | --help)
            show_help
            exit 0
            ;;
        -b | --batch)
            BATCH_MODE=true
            shift
            ;;
        -n | --dry-run)
            DRY_RUN=true
            shift
            ;;
        -d | --dirs)
            if [[ -n "${2:-}" ]]; then
                IFS=',' read -ra CUSTOM_DIRS <<<"$2"
                shift 2
            else
                print_error "Option --dirs requires an argument"
                exit 2
            fi
            ;;
        -v | --verbose)
            VERBOSE=true
            shift
            ;;
        -*)
            print_error "Unknown option: $1"
            echo "Use --help for usage information"
            exit 2
            ;;
        *)
            if [[ -z "${START_DIR_SET:-}" ]]; then
                START_DIR="$1"
                START_DIR_SET=true
                ORIGINAL_START_DIR="$1"
            else
                print_error "Multiple directories specified. Only one directory is allowed."
                exit 2
            fi
            shift
            ;;
        esac
    done
    
    # Store the original input for display purposes (empty if not set)
    ORIGINAL_START_DIR="${ORIGINAL_START_DIR:-}"
}

# Function to validate arguments
validate_arguments() {
    # Store original input before resolving
    local original_input="$START_DIR"
    
    # For current directory, use PWD instead of the script's location
    if [[ "$START_DIR" == "." ]]; then
        START_DIR="$PWD"
        print_debug "Using current working directory: $START_DIR"
    fi
    
    # Resolve and validate directory
    START_DIR=$(realpath "$START_DIR" 2>/dev/null) || {
        print_error "Directory '$START_DIR' does not exist or is not accessible!"
        exit 1
    }

    if [[ ! -d "$START_DIR" ]]; then
        print_error "Directory '$START_DIR' does not exist!"
        exit 1
    fi

    if [[ ! -r "$START_DIR" ]]; then
        print_error "Directory '$START_DIR' is not readable!"
        exit 1
    fi

    # Use custom directories if provided, otherwise use defaults
    if [[ ${#CUSTOM_DIRS[@]} -eq 0 ]]; then
        CUSTOM_DIRS=("${DEFAULT_DIRS[@]}")
    fi

    # Create a user-friendly display name
    START_DIR_DISPLAY=$(get_start_dir_display "$START_DIR" "$ORIGINAL_START_DIR")

    print_debug "Original input: '$ORIGINAL_START_DIR'"
    print_debug "Target directories: ${CUSTOM_DIRS[*]}"
    print_debug "Starting directory (resolved): $START_DIR"
    print_debug "Display name: $START_DIR_DISPLAY"
    print_debug "Batch mode: $BATCH_MODE"
    print_debug "Dry run: $DRY_RUN"
}

# Function to get directory size in human readable format
get_dir_size() {
    if [[ -d "$1" ]]; then
        # Use du with better error handling and fallback
        local size
        size=$(du -sh "$1" 2>/dev/null | cut -f1)
        if [[ -n "$size" ]]; then
            echo "$size"
        else
            # Fallback: try with different approach
            size=$(find "$1" -type f -exec ls -l {} \; 2>/dev/null | awk '{sum += $5} END {
                if (sum < 1024) print sum "B"
                else if (sum < 1048576) printf "%.1fK\n", sum/1024
                else if (sum < 1073741824) printf "%.1fM\n", sum/1048576
                else printf "%.1fG\n", sum/1073741824
            }' || echo "0B")
            echo "$size"
        fi
    else
        echo "0B"
    fi
}

# Function to find directories - FIXED VERSION
find_target_directories() {
    local dir_name="$1"
    local -a found_dirs=()

    print_debug "Searching for directories named '$dir_name' in '$START_DIR'"
    
    # Use find with -print (newline-terminated) to match mapfile -t
    while IFS= read -r dir; do
        # Ensure the directory still exists and is actually a directory
        if [[ -d "$dir" ]]; then
            found_dirs+=("$dir")
            print_debug "Found directory: $dir"
        else
            print_debug "Skipping non-directory or non-existent: $dir"
        fi
    done < <(find "$START_DIR" -type d -name "$dir_name" -print 2>/dev/null)

    print_debug "Total directories found: ${#found_dirs[@]}"
    
    # Output the found directories
    printf '%s\n' "${found_dirs[@]}"
}

# Function to remove directories interactively
remove_directories_interactive() {
    local dir_name="$1"
    local count=0
    local skipped=0

    print_info "Searching for '$dir_name' directories in $START_DIR_DISPLAY..."

    local -a dirs
    mapfile -t dirs < <(find_target_directories "$dir_name")

    print_debug "Directories found by mapfile: ${#dirs[@]}"
    
    if [[ ${#dirs[@]} -eq 0 ]]; then
        print_info "No '$dir_name' directories found."
        return 0
    fi

    for dir in "${dirs[@]}"; do
        # Skip empty entries
        if [[ -z "$dir" ]]; then
            print_debug "Skipping empty directory entry"
            continue
        fi
        
        # Double-check directory exists
        if [[ ! -d "$dir" ]]; then
            print_debug "Directory no longer exists: $dir"
            continue
        fi
        
        local size
        local rel_path
        size=$(get_dir_size "$dir")
        rel_path=$(get_relative_path "$dir")
        
        print_info "Found: ${rel_path} (${size})"

        if [[ "$DRY_RUN" == "true" ]]; then
            print_info "[DRY RUN] Would delete: ${rel_path} (${size})"
            ((count++))
            continue
        fi

        # Ask for confirmation before deletion
        local reply
        echo -n "Delete this directory? [y/N]: "
        read -n 1 -r reply
        echo

        if [[ $reply =~ ^[Yy]$ ]]; then
            if rm -rf "$dir" 2>/dev/null; then
                print_success "Deleted: ${rel_path} (${size})"
                ((count++))
            else
                print_error "Failed to delete: ${rel_path}"
            fi
        else
            print_info "Skipped: ${rel_path}"
            ((skipped++))
        fi
    done

    if [[ "$DRY_RUN" == "true" ]]; then
        print_info "[DRY RUN] Would delete $count '$dir_name' directories."
    else
        print_success "Deleted $count '$dir_name' directories."
        if [[ $skipped -gt 0 ]]; then
            print_info "Skipped $skipped '$dir_name' directories."
        fi
    fi
}

# Function to remove directories in batch mode
remove_directories_batch() {
    local dir_name="$1"
    local count=0

    print_info "Searching for '$dir_name' directories in $START_DIR_DISPLAY..."

    local -a dirs
    mapfile -t dirs < <(find_target_directories "$dir_name")

    print_debug "Directories found by mapfile: ${#dirs[@]}"
    
    if [[ ${#dirs[@]} -eq 0 ]]; then
        print_info "No '$dir_name' directories found."
        return 0
    fi

    for dir in "${dirs[@]}"; do
        # Skip empty entries
        if [[ -z "$dir" ]]; then
            print_debug "Skipping empty directory entry"
            continue
        fi
        
        # Double-check directory exists
        if [[ ! -d "$dir" ]]; then
            print_debug "Directory no longer exists: $dir"
            continue
        fi
        
        local size
        local rel_path
        size=$(get_dir_size "$dir")
        rel_path=$(get_relative_path "$dir")

        if [[ "$DRY_RUN" == "true" ]]; then
            print_info "[DRY RUN] Would delete: ${rel_path} (${size})"
            ((count++))
        else
            if rm -rf "$dir" 2>/dev/null; then
                print_success "Deleted: ${rel_path} (${size})"
                ((count++))
            else
                print_error "Failed to delete: ${rel_path}"
            fi
        fi
    done

    if [[ "$DRY_RUN" == "true" ]]; then
        print_info "[DRY RUN] Would delete $count '$dir_name' directories."
    else
        print_success "Deleted $count '$dir_name' directories."
    fi
}

# Function to show summary
show_summary() {
    local mode_text="Scanning"
    if [[ "$DRY_RUN" == "true" ]]; then
        mode_text="Dry run"
    fi

    print_info "$mode_text complete!"

    # Count remaining directories for each target type
    echo
    echo "=== SUMMARY ==="

    for dir_name in "${CUSTOM_DIRS[@]}"; do
        local remaining
        remaining=$(find "$START_DIR" -type d -name "$dir_name" 2>/dev/null | wc -l)
        echo "Remaining '$dir_name' directories: $remaining"
    done
}

# Main function
main() {
    # Parse command line arguments
    parse_arguments "$@"

    # Validate arguments
    validate_arguments

    # Show header
    echo -e "=== ${BLUE}Node Modules & Virtual Environment Cleaner${NC} ==="
    echo -e "Starting directory: $START_DIR_DISPLAY"

    if [[ "$DRY_RUN" == "true" ]]; then
        echo -e "${YELLOW}DRY RUN MODE - No files will be deleted${NC}"
    fi

    if [[ "$BATCH_MODE" == "true" ]]; then
        echo -e "${YELLOW}BATCH MODE - No confirmation required${NC}"
    fi

    echo -e "Target directories: ${CUSTOM_DIRS[*]}"
    echo

    # Process each directory type
    for dir_name in "${CUSTOM_DIRS[@]}"; do
        if [[ "$BATCH_MODE" == "true" ]]; then
            remove_directories_batch "$dir_name"
        else
            remove_directories_interactive "$dir_name"
        fi
        echo
    done

    # Show final summary
    show_summary

    if [[ "$DRY_RUN" == "true" ]]; then
        print_success "Dry run completed! Use without --dry-run to actually delete files."
    else
        print_success "Script completed!"
    fi
}

# Run main function with all arguments
main "$@"
