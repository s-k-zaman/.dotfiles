#!/bin/bash

# Script to recursively remove node_modules and venv directories
# Author: github.com/s-k-zaman
# Version: 1.0
set -euo pipefail # Exit on error, undefined vars, pipe failures

# Default values
START_DIR="."
BATCH_MODE=false
DRY_RUN=false
DELETE_ALL=false
ALL_TYPE=""
FORCE=false
YES=false
CUSTOM_DIRS=()
DEFAULT_DIRS=("node_modules" "venv" ".venv" "__pycache__" ".pytest_cache")

# Colors
readonly NC='\033[0m'
readonly RED='\033[0;31m'
readonly GREEN='\033[0;32m'
readonly YELLOW='\033[1;33m'
readonly BLUE='\033[0;34m'

# Function to show help
show_help() {
    cat <<EOF
Node Modules, Virtual Environment & Directory Cleaner

DESCRIPTION:
    Recursively finds and removes common development directories that can be safely
    deleted and regenerated (node_modules, venv, __pycache__, etc.)

USAGE:
    $(basename "$0") [OPTIONS] [DIRECTORY]

ARGUMENTS:
    DIRECTORY           Starting directory to search (default: current working directory)

OPTIONS:
    -h, --help          Show this help message and exit
    -b, --batch         Run in batch mode (no confirmation required)
    -n, --dry-run       Show what would be deleted without actually deleting
    -d, --dirs DIRS     Comma-separated list of directory names to remove
                        (default: node_modules,venv,.venv,__pycache__,.pytest_cache)
    -a, --all           Delete all found directories without individual confirmation
    --all-type TYPE     Delete all directories of specific type without individual confirmation
    -f, --force         Use rm -rf instead of rm -r (bypass trash-cli)
    -y, --yes           Skip all confirmations
    -v, --verbose       Enable verbose output

EXAMPLES:
    $(basename "$0")                                    # Interactive mode in current directory
    $(basename "$0") /path/to/project                   # Interactive mode in specific directory
    $(basename "$0") --batch ~/projects                 # Batch mode in ~/projects
    $(basename "$0") --dry-run .                        # See what would be deleted
    $(basename "$0") --dirs "node_modules,dist" .       # Only remove node_modules and dist
    $(basename "$0") --all                              # Delete all found directories with one confirmation
    $(basename "$0") --all --yes                        # Delete all found directories without confirmation
    $(basename "$0") --all-type venv                    # Delete all venv directories with one confirmation
    $(basename "$0") --dirs texts,test --all            # Delete all texts and test directories
    $(basename "$0") --dirs texts,test --all-type texts # Delete only texts directories
    $(basename "$0") --all --force                      # Delete all with rm -rf (no trash)

EXIT CODES:
    0    Success
    1    General error
    2    Invalid arguments
EOF
}

# Function to print colored output
print_info() {
    echo -e "${YELLOW}[INFO]${NC} $1"
}

print_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

print_error() {
    echo -e "${RED}[ERROR]${NC} $1" >&2
}

print_debug() {
    if [[ "${VERBOSE:-false}" == "true" ]]; then
        echo -e "${BLUE}[DEBUG]${NC} $1" >&2
    fi
}

# Function to get a user-friendly display name for the starting directory
get_start_dir_display() {
    local resolved_path="$1"
    local original_input="${2:-}"

    # If user specified current directory explicitly (. or ./), or no directory (default)
    if [[ "$original_input" == "." || "$original_input" == "./" || -z "$original_input" ]]; then
        echo "current directory ($(basename "$resolved_path"))"
    else
        # For any other path, show the original user input
        echo "$original_input"
    fi
}

# Function to convert absolute path to relative path for file/directory display
get_relative_path() {
    local abs_path="$1"
    local base_path="$START_DIR"

    # Convert to absolute paths for comparison
    abs_path=$(realpath "$abs_path" 2>/dev/null || echo "$abs_path")
    base_path=$(realpath "$base_path" 2>/dev/null || echo "$base_path")

    # If the path is the same as the base path, show current directory indicator
    if [[ "$abs_path" == "$base_path" ]]; then
        echo "./$(basename "$base_path")"
    # If the path is under START_DIR, show relative path
    elif [[ "$abs_path" == "$base_path"* ]]; then
        local rel_path="${abs_path#$base_path}"
        rel_path="${rel_path#/}" # Remove leading slash
        if [[ -z "$rel_path" ]]; then
            echo "./$(basename "$base_path")"
        else
            echo "./$rel_path"
        fi
    else
        # For paths outside START_DIR, show absolute path
        echo "$abs_path"
    fi
}

# Function to parse command line arguments
parse_arguments() {
    while [[ $# -gt 0 ]]; do
        case $1 in
        -h | --help)
            show_help
            exit 0
            ;;
        -b | --batch)
            BATCH_MODE=true
            shift
            ;;
        -n | --dry-run)
            DRY_RUN=true
            shift
            ;;
        -d | --dirs)
            if [[ -n "${2:-}" ]]; then
                IFS=',' read -ra CUSTOM_DIRS <<<"$2"
                shift 2
            else
                print_error "Option --dirs requires an argument"
                exit 2
            fi
            ;;
        -a | --all)
            DELETE_ALL=true
            shift
            ;;
        --all-type)
            if [[ -n "${2:-}" ]]; then
                ALL_TYPE="$2"
                shift 2
            else
                print_error "Option --all-type requires an argument"
                exit 2
            fi
            ;;
        -f | --force)
            FORCE=true
            shift
            ;;
        -y | --yes)
            YES=true
            shift
            ;;
        -v | --verbose)
            VERBOSE=true
            shift
            ;;
        -*)
            print_error "Unknown option: $1"
            echo "Use --help for usage information"
            exit 2
            ;;
        *)
            if [[ -z "${START_DIR_SET:-}" ]]; then
                START_DIR="$1"
                START_DIR_SET=true
                ORIGINAL_START_DIR="$1"
            else
                print_error "Multiple directories specified. Only one directory is allowed."
                exit 2
            fi
            shift
            ;;
        esac
    done

    # Store the original input for display purposes (empty if not set)
    ORIGINAL_START_DIR="${ORIGINAL_START_DIR:-}"

    # Validate conflicting options
    if [[ "$DELETE_ALL" == "true" && -n "$ALL_TYPE" ]]; then
        print_error "Cannot use both --all and --all-type options together"
        exit 2
    fi

    # Note: --batch now works similar to --all, so we don't need to prevent combining them
    # But we still prevent --all and --all-type together
    if [[ "$DELETE_ALL" == "true" && -n "$ALL_TYPE" ]]; then
        print_error "Cannot use both --all and --all-type options together"
        exit 2
    fi
}

# Function to validate arguments
validate_arguments() {
    # Store original input before resolving
    local original_input="$START_DIR"

    # For current directory, use PWD instead of the script's location
    if [[ "$START_DIR" == "." ]]; then
        START_DIR="$PWD"
        print_debug "Using current working directory: $START_DIR"
    fi

    # Resolve and validate directory
    START_DIR=$(realpath "$START_DIR" 2>/dev/null) || {
        print_error "Directory '$START_DIR' does not exist or is not accessible!"
        exit 1
    }

    if [[ ! -d "$START_DIR" ]]; then
        print_error "Directory '$START_DIR' does not exist!"
        exit 1
    fi

    if [[ ! -r "$START_DIR" ]]; then
        print_error "Directory '$START_DIR' is not readable!"
        exit 1
    fi

    # Use custom directories if provided, otherwise use defaults
    if [[ ${#CUSTOM_DIRS[@]} -eq 0 ]]; then
        CUSTOM_DIRS=("${DEFAULT_DIRS[@]}")
    fi

    # Validate ALL_TYPE if provided
    if [[ -n "$ALL_TYPE" ]]; then
        local type_found=false
        for dir_name in "${CUSTOM_DIRS[@]}"; do
            if [[ "$dir_name" == "$ALL_TYPE" ]]; then
                type_found=true
                break
            fi
        done
        if [[ "$type_found" == "false" ]]; then
            print_error "Directory type '$ALL_TYPE' not found in target directories: ${CUSTOM_DIRS[*]}"
            exit 2
        fi
    fi

    # Create a user-friendly display name
    START_DIR_DISPLAY=$(get_start_dir_display "$START_DIR" "$ORIGINAL_START_DIR")

    print_debug "Original input: '$ORIGINAL_START_DIR'"
    print_debug "Target directories: ${CUSTOM_DIRS[*]}"
    print_debug "Starting directory (resolved): $START_DIR"
    print_debug "Display name: $START_DIR_DISPLAY"
    print_debug "Delete all: $DELETE_ALL"
    print_debug "All type: $ALL_TYPE"
    print_debug "Force: $FORCE"
    print_debug "Yes: $YES"
    print_debug "Batch mode: $BATCH_MODE"
    print_debug "Dry run: $DRY_RUN"
}

# Function to get directory size in human readable format
get_dir_size() {
    if [[ ! -d "$1" ]]; then
        echo "0B"
        return
    fi

    local size
    # Try du command first
    if size=$(du -sh "$1" 2>/dev/null | cut -f1) && [[ -n "$size" && "$size" != "0" ]]; then
        echo "$size"
        return
    fi

    # Fallback: count files and calculate size
    local total_size
    total_size=$(find "$1" -type f -exec ls -l {} \; 2>/dev/null | awk '{sum += $5} END {
        if (NR == 0 || sum == 0) print "0B"
        else if (sum < 1024) print sum "B"
        else if (sum < 1048576) printf "%.1fK\n", sum/1024
        else if (sum < 1073741824) printf "%.1fM\n", sum/1048576
        else printf "%.1fG\n", sum/1073741824
    }')

    if [[ -z "$total_size" ]]; then
        echo "0B"
    else
        echo "$total_size"
    fi
}

# Function to find directories
find_target_directories() {
    local dir_name="$1"
    local -a found_dirs=()

    print_debug "Searching for directories named '$dir_name' in '$START_DIR'"

    # Use find with -print (newline-terminated) to match mapfile -t
    while IFS= read -r dir; do
        # Ensure the directory still exists and is actually a directory
        if [[ -d "$dir" ]]; then
            found_dirs+=("$dir")
            print_debug "Found directory: $dir"
        else
            print_debug "Skipping non-directory or non-existent: $dir"
        fi
    done < <(find "$START_DIR" -type d -name "$dir_name" -print 2>/dev/null)

    print_debug "Total directories found: ${#found_dirs[@]}"

    # Output the found directories
    printf '%s\n' "${found_dirs[@]}"
}

# Function to delete a directory with proper error handling
delete_directory() {
    local dir="$1"
    local rel_path="$2"
    local size="$3"

    local rm_cmd="rm -r"
    if [[ "$FORCE" == "true" ]]; then
        rm_cmd="rm -rf"
    fi

    if [[ "$DRY_RUN" == "true" ]]; then
        print_info "[DRY RUN] Would delete: ${rel_path} (${size})"
        return 0
    fi

    print_debug "Attempting to delete: $dir"
    print_debug "Using command: $rm_cmd"

    # Check if directory still exists before deletion
    if [[ ! -d "$dir" ]]; then
        print_error "Directory no longer exists: ${rel_path}"
        return 1
    fi

    # Check if directory is writable
    if [[ ! -w "$dir" ]]; then
        print_debug "Directory not writable: ${rel_path}"
        print_debug "Trying with parent directory permissions..."
        local parent_dir
        parent_dir=$(dirname "$dir")
        if [[ ! -w "$parent_dir" ]]; then
            print_error "No write permission for parent directory: $(get_relative_path "$parent_dir")"
            print_error "Failed to delete: ${rel_path} (Permission denied)"
            return 1
        fi
    fi

    # Attempt deletion with detailed error reporting
    local error_output
    if error_output=$($rm_cmd "$dir" 2>&1); then
        print_success "Deleted: ${rel_path} (${size})"
        return 0
    else
        print_error "Failed to delete: ${rel_path}"
        print_debug "Error details: $error_output"

        # Common error analysis
        if [[ "$error_output" == *"Permission denied"* ]]; then
            print_error "Reason: Permission denied. Try running with sudo or use --force"
        elif [[ "$error_output" == *"Directory not empty"* ]]; then
            print_error "Reason: Directory not empty. Use --force to override"
        elif [[ "$error_output" == *"No such file or directory"* ]]; then
            print_error "Reason: Directory was deleted by another process"
        else
            print_error "Reason: $error_output"
        fi
        return 1
    fi
}

# Function to remove directories interactively
remove_directories_interactive() {
    local dir_name="$1"
    local count=0
    local skipped=0

    print_info "Searching for '$dir_name' directories in $START_DIR_DISPLAY..."

    local -a dirs
    mapfile -t dirs < <(find_target_directories "$dir_name")

    print_debug "Directories found by mapfile: ${#dirs[@]}"

    if [[ ${#dirs[@]} -eq 0 ]]; then
        print_info "No '$dir_name' directories found."
        return 0
    fi

    for dir in "${dirs[@]}"; do
        # Skip empty entries
        if [[ -z "$dir" ]]; then
            print_debug "Skipping empty directory entry"
            continue
        fi

        # Double-check directory exists
        if [[ ! -d "$dir" ]]; then
            print_debug "Directory no longer exists: $dir"
            continue
        fi

        local size
        local rel_path
        size=$(get_dir_size "$dir")
        rel_path=$(get_relative_path "$dir")

        print_info "Found: ${rel_path} (${size})"

        if [[ "$DRY_RUN" == "true" ]]; then
            print_info "[DRY RUN] Would delete: ${rel_path} (${size})"
            ((count++))
            continue
        fi

        # Ask for confirmation before deletion
        local reply
        echo -n "Delete this directory? [y/N]: "
        read -n 1 -r reply
        echo

        if [[ $reply =~ ^[Yy]$ ]]; then
            if delete_directory "$dir" "$rel_path" "$size"; then
                ((count++))
            fi
        else
            print_info "Skipped: ${rel_path}"
            ((skipped++))
        fi
    done

    if [[ "$DRY_RUN" == "true" ]]; then
        print_info "[DRY RUN] Would delete $count '$dir_name' directories."
    else
        print_success "Deleted $count '$dir_name' directories."
        if [[ $skipped -gt 0 ]]; then
            print_info "Skipped $skipped '$dir_name' directories."
        fi
    fi
}

# Function to remove directories in batch mode
remove_directories_batch() {
    local dir_name="$1"
    local count=0

    print_info "Searching for '$dir_name' directories in $START_DIR_DISPLAY..."

    local -a dirs
    mapfile -t dirs < <(find_target_directories "$dir_name")

    print_debug "Directories found by mapfile: ${#dirs[@]}"

    if [[ ${#dirs[@]} -eq 0 ]]; then
        print_info "No '$dir_name' directories found."
        return 0
    fi

    for dir in "${dirs[@]}"; do
        # Skip empty entries
        if [[ -z "$dir" ]]; then
            print_debug "Skipping empty directory entry"
            continue
        fi

        # Double-check directory exists
        if [[ ! -d "$dir" ]]; then
            print_debug "Directory no longer exists: $dir"
            continue
        fi

        local size
        local rel_path
        size=$(get_dir_size "$dir")
        rel_path=$(get_relative_path "$dir")

        if delete_directory "$dir" "$rel_path" "$size"; then
            ((count++))
        fi
    done

    if [[ "$DRY_RUN" == "true" ]]; then
        print_info "[DRY RUN] Would delete $count '$dir_name' directories."
    else
        print_success "Deleted $count '$dir_name' directories."
    fi
}

# Function to collect all directories for bulk operations
collect_all_directories() {
    local -a all_dirs=()
    local -a dir_types_to_process=()

    # Determine which directory types to process
    if [[ -n "$ALL_TYPE" ]]; then
        dir_types_to_process=("$ALL_TYPE")
    else
        dir_types_to_process=("${CUSTOM_DIRS[@]}")
    fi

    # Collect all directories (suppress debug output during collection)
    for dir_name in "${dir_types_to_process[@]}"; do
        print_debug "Collecting '$dir_name' directories..."

        # Use find directly instead of the function to avoid debug contamination
        while IFS= read -r dir; do
            # Skip empty entries
            if [[ -z "$dir" ]]; then
                continue
            fi

            # Double-check directory exists
            if [[ -d "$dir" ]]; then
                all_dirs+=("$dir")
                print_debug "Collected directory: $dir"
            fi
        done < <(find "$START_DIR" -type d -name "$dir_name" -print 2>/dev/null)
    done

    print_debug "Total directories collected: ${#all_dirs[@]}"
    printf '%s\n' "${all_dirs[@]}"
}

# Function to remove all directories with bulk confirmation
remove_directories_all() {
    local -a all_dirs
    local -a filtered_dirs

    print_info "Searching for directories in $START_DIR_DISPLAY..."
    mapfile -t all_dirs < <(collect_all_directories)

    # Filter out empty entries
    filtered_dirs=()
    for dir in "${all_dirs[@]}"; do
        if [[ -n "$dir" && -d "$dir" ]]; then
            filtered_dirs+=("$dir")
        fi
    done

    local total_count=${#filtered_dirs[@]}

    if [[ $total_count -eq 0 ]]; then
        if [[ -n "$ALL_TYPE" ]]; then
            print_info "No '$ALL_TYPE' directories found."
        else
            print_info "No target directories found."
        fi
        return 0
    fi

    # Show all found directories
    echo
    if [[ -n "$ALL_TYPE" ]]; then
        print_info "Found $total_count '$ALL_TYPE' directories:"
    else
        print_info "Found $total_count directories:"
    fi

    for dir in "${filtered_dirs[@]}"; do
        local size
        local rel_path
        size=$(get_dir_size "$dir")
        rel_path=$(get_relative_path "$dir")
        print_info "Found: ${rel_path} (${size})"
    done

    echo

    # Ask for confirmation unless --yes is provided or it's a dry run
    if [[ "$DRY_RUN" == "false" && "$YES" == "false" ]]; then
        local reply
        if [[ -n "$ALL_TYPE" ]]; then
            echo -n "Delete all $total_count '$ALL_TYPE' directories? [y/N]: "
        else
            echo -n "Delete all $total_count directories? [y/N]: "
        fi
        read -n 1 -r reply
        echo

        if [[ ! $reply =~ ^[Yy]$ ]]; then
            print_info "Operation cancelled."
            return 0
        fi
    fi

    # Delete all directories
    local success_count=0
    local fail_count=0

    echo
    print_info "Deleting directories..."

    # Temporarily disable exit on error for the loop
    set +e

    local dir_index=0
    for dir in "${filtered_dirs[@]}"; do
        ((dir_index++))

        local size
        local rel_path
        size=$(get_dir_size "$dir")
        rel_path=$(get_relative_path "$dir")

        print_debug "Processing directory $dir_index of $total_count: $rel_path"

        if delete_directory "$dir" "$rel_path" "$size"; then
            ((success_count++))
        else
            ((fail_count++))
        fi

        print_debug "Completed processing: $rel_path (Success: $success_count, Failed: $fail_count)"
    done

    # Re-enable exit on error
    set -e

    echo
    if [[ "$DRY_RUN" == "true" ]]; then
        print_info "[DRY RUN] Would delete $total_count directories."
    else
        print_success "Successfully deleted $success_count directories."
        if [[ $fail_count -gt 0 ]]; then
            print_error "Failed to delete $fail_count directories."
        fi
    fi
}

# Function to show summary
show_summary() {
    local mode_text="Scanning"
    if [[ "$DRY_RUN" == "true" ]]; then
        mode_text="Dry run"
    fi

    print_info "$mode_text complete!"

    # Count remaining directories for each target type
    echo
    echo "=== SUMMARY ==="

    for dir_name in "${CUSTOM_DIRS[@]}"; do
        local remaining
        remaining=$(find "$START_DIR" -type d -name "$dir_name" 2>/dev/null | wc -l)
        echo "Remaining '$dir_name' directories: $remaining"
    done
}

# Main function
main() {
    # Parse command line arguments
    parse_arguments "$@"

    # Validate arguments
    validate_arguments

    # Show header
    echo -e "=== ${BLUE}Node Modules & Virtual Environment Cleaner${NC} ==="
    echo -e "Starting directory: $START_DIR_DISPLAY"

    if [[ "$DRY_RUN" == "true" ]]; then
        echo -e "${YELLOW}DRY RUN MODE - No files will be deleted${NC}"
    fi

    if [[ "$FORCE" == "true" ]]; then
        echo -e "${RED}FORCE MODE - Using rm -rf (bypasses trash)${NC}"
    fi

    if [[ "$DELETE_ALL" == "true" ]]; then
        echo -e "${YELLOW}ALL MODE - Deleting all found directories${NC}"
    elif [[ -n "$ALL_TYPE" ]]; then
        echo -e "${YELLOW}ALL-TYPE MODE - Deleting all '$ALL_TYPE' directories${NC}"
    elif [[ "$BATCH_MODE" == "true" ]]; then
        echo -e "${YELLOW}BATCH MODE - Deleting all found directories${NC}"
    fi

    echo -e "Target directories: ${CUSTOM_DIRS[*]}"
    echo

    # Choose processing mode
    if [[ "$DELETE_ALL" == "true" || -n "$ALL_TYPE" || "$BATCH_MODE" == "true" ]]; then
        # Bulk delete mode (--all, --all-type, or --batch)
        remove_directories_all
    else
        # Individual interactive mode
        for dir_name in "${CUSTOM_DIRS[@]}"; do
            remove_directories_interactive "$dir_name"
            echo
        done

        # Show final summary only for individual mode
        show_summary
    fi

    if [[ "$DRY_RUN" == "true" ]]; then
        print_success "Dry run completed! Use without --dry-run to actually delete files."
    else
        print_success "Script completed!"
    fi
}

# Run main function with all arguments
main "$@"
