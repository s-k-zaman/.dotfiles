#!/bin/bash

# Script to recursively remove node_modules and venv directories
# Author: github.com/s-k-zaman
# Version: 2.0

set -euo pipefail # Exit on error, undefined vars, pipe failures

# Default values
START_DIR="."
BATCH_MODE=false
DRY_RUN=false
CUSTOM_DIRS=()
DEFAULT_DIRS=("node_modules" "venv" ".venv" "__pycache__" ".pytest_cache")

# Colors
readonly NC='\033[0m'
readonly RED='\033[0;31m'
readonly GREEN='\033[0;32m'
readonly YELLOW='\033[1;33m'
readonly BLUE='\033[0;34m'

# Function to show help
show_help() {
    cat <<EOF
Node Modules & Virtual Environment Cleaner

DESCRIPTION:
    Recursively finds and removes common development directories that can be safely
    deleted and regenerated (node_modules, venv, __pycache__, etc.)

USAGE:
    $(basename "$0") [OPTIONS] [DIRECTORY]

ARGUMENTS:
    DIRECTORY           Starting directory to search (default: current directory)

OPTIONS:
    -h, --help          Show this help message and exit
    -b, --batch         Run in batch mode (no confirmation required)
    -n, --dry-run       Show what would be deleted without actually deleting
    -d, --dirs DIRS     Comma-separated list of directory names to remove
                        (default: node_modules,venv,.venv,__pycache__,.pytest_cache)
    -v, --verbose       Enable verbose output

EXAMPLES:
    $(basename "$0")                                    # Interactive mode in current directory
    $(basename "$0") /path/to/project                   # Interactive mode in specific directory
    $(basename "$0") --batch ~/projects                 # Batch mode in ~/projects
    $(basename "$0") --dry-run .                        # See what would be deleted
    $(basename "$0") --dirs "node_modules,dist" .       # Only remove node_modules and dist
    $(basename "$0") -b -d "venv,.venv" ~/python-proj   # Batch remove only Python virtual envs

EXIT CODES:
    0    Success
    1    General error
    2    Invalid arguments
EOF
}

# Function to print colored output
print_info() {
    echo -e "${YELLOW}[INFO]${NC} $1"
}

print_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

print_error() {
    echo -e "${RED}[ERROR]${NC} $1" >&2
}

print_debug() {
    if [[ "${VERBOSE:-false}" == "true" ]]; then
        echo -e "${BLUE}[DEBUG]${NC} $1"
    fi
}

# Function to convert absolute path to relative path
get_relative_path() {
    local abs_path="$1"
    local base_path="$START_DIR"

    # If the path is under START_DIR, show relative path
    if [[ "$abs_path" == "$base_path"* ]]; then
        local rel_path="${abs_path#$base_path}"
        rel_path="${rel_path#/}" # Remove leading slash
        if [[ -z "$rel_path" ]]; then
            echo "."
        else
            echo "./$rel_path"
        fi
    else
        echo "$abs_path"
    fi
}

# Function to parse command line arguments
parse_arguments() {
    while [[ $# -gt 0 ]]; do
        case $1 in
        -h | --help)
            show_help
            exit 0
            ;;
        -b | --batch)
            BATCH_MODE=true
            shift
            ;;
        -n | --dry-run)
            DRY_RUN=true
            shift
            ;;
        -d | --dirs)
            if [[ -n "${2:-}" ]]; then
                IFS=',' read -ra CUSTOM_DIRS <<<"$2"
                shift 2
            else
                print_error "Option --dirs requires an argument"
                exit 2
            fi
            ;;
        -v | --verbose)
            VERBOSE=true
            shift
            ;;
        -*)
            print_error "Unknown option: $1"
            echo "Use --help for usage information"
            exit 2
            ;;
        *)
            if [[ -z "${START_DIR_SET:-}" ]]; then
                START_DIR="$1"
                START_DIR_SET=true
            else
                print_error "Multiple directories specified. Only one directory is allowed."
                exit 2
            fi
            shift
            ;;
        esac
    done
}

# Function to validate arguments
validate_arguments() {
    # Resolve and validate directory
    START_DIR=$(realpath "$START_DIR" 2>/dev/null) || {
        print_error "Directory '$START_DIR' does not exist or is not accessible!"
        exit 1
    }

    if [[ ! -d "$START_DIR" ]]; then
        print_error "Directory '$START_DIR' does not exist!"
        exit 1
    fi

    if [[ ! -r "$START_DIR" ]]; then
        print_error "Directory '$START_DIR' is not readable!"
        exit 1
    fi

    # Use custom directories if provided, otherwise use defaults
    if [[ ${#CUSTOM_DIRS[@]} -eq 0 ]]; then
        CUSTOM_DIRS=("${DEFAULT_DIRS[@]}")
    fi

    print_debug "Target directories: ${CUSTOM_DIRS[*]}"
    print_debug "Starting directory: $START_DIR"
    print_debug "Batch mode: $BATCH_MODE"
    print_debug "Dry run: $DRY_RUN"
}

# Function to get directory size in human readable format
get_dir_size() {
    if [[ -d "$1" ]]; then
        du -sh "$1" 2>/dev/null | cut -f1 || echo "0B"
    else
        echo "0B"
    fi
}

# Function to find directories
find_target_directories() {
    local -a found_dirs=()
    local dir_name="$1"

    while IFS= read -r -d '' dir; do
        if [[ -d "$dir" ]]; then
            found_dirs+=("$dir")
        fi
    done < <(find "$START_DIR" -type d -name "$dir_name" -print0 2>/dev/null)

    printf '%s\n' "${found_dirs[@]}"
}

# Function to remove directories interactively
remove_directories_interactive() {
    local dir_name="$1"
    local count=0
    local skipped=0

    print_info "Searching for '$dir_name' directories in $(get_relative_path "$START_DIR")..."

    local -a dirs
    mapfile -t dirs < <(find_target_directories "$dir_name")

    if [[ ${#dirs[@]} -eq 0 ]]; then
        print_info "No '$dir_name' directories found."
        return 0
    fi

    for dir in "${dirs[@]}"; do
        local size rel_path
        size=$(get_dir_size "$dir")
        rel_path=$(get_relative_path "$dir")
        print_info "Found: $rel_path ($size)"

        if [[ "$DRY_RUN" == "true" ]]; then
            print_info "[DRY RUN] Would delete: $rel_path ($size)"
            ((count++))
            continue
        fi

        # Ask for confirmation before deletion
        local reply
        echo -e -n "Delete this directory? [y/N]: "
        read -n 1 -r reply
        echo

        if [[ $reply =~ ^[Yy]$ ]]; then
            if rm -rf "$dir" 2>/dev/null; then
                print_success "Deleted: $rel_path ($size)"
                ((count++))
            else
                print_error "Failed to delete: $rel_path"
            fi
        else
            print_info "Skipped: $rel_path"
            ((skipped++))
        fi
    done

    if [[ "$DRY_RUN" == "true" ]]; then
        print_info "[DRY RUN] Would delete $count '$dir_name' directories."
    else
        print_success "Deleted $count '$dir_name' directories."
        if [[ $skipped -gt 0 ]]; then
            print_info "Skipped $skipped '$dir_name' directories."
        fi
    fi
}

# Function to remove directories in batch mode
remove_directories_batch() {
    local dir_name="$1"
    local count=0

    print_info "Searching for '$dir_name' directories in $(get_relative_path "$START_DIR")..."

    local -a dirs
    mapfile -t dirs < <(find_target_directories "$dir_name")

    if [[ ${#dirs[@]} -eq 0 ]]; then
        print_info "No '$dir_name' directories found."
        return 0
    fi

    for dir in "${dirs[@]}"; do
        local size rel_path
        size=$(get_dir_size "$dir")
        rel_path=$(get_relative_path "$dir")

        if [[ "$DRY_RUN" == "true" ]]; then
            print_info "[DRY RUN] Would delete: $rel_path ($size)"
            ((count++))
        else
            if rm -rf "$dir" 2>/dev/null; then
                print_success "Deleted: $rel_path ($size)"
                ((count++))
            else
                print_error "Failed to delete: $rel_path"
            fi
        fi
    done

    if [[ "$DRY_RUN" == "true" ]]; then
        print_info "[DRY RUN] Would delete $count '$dir_name' directories."
    else
        print_success "Deleted $count '$dir_name' directories."
    fi
}

# Function to show summary
show_summary() {
    local mode_text="Scanning"
    if [[ "$DRY_RUN" == "true" ]]; then
        mode_text="Dry run"
    fi

    print_info "$mode_text complete!"

    # Count remaining directories for each target type
    echo
    echo "=== SUMMARY ==="

    for dir_name in "${CUSTOM_DIRS[@]}"; do
        local remaining
        remaining=$(find "$START_DIR" -type d -name "$dir_name" 2>/dev/null | wc -l)
        echo "Remaining '$dir_name' directories: $remaining"
    done
}

# Main function
main() {
    # Parse command line arguments
    parse_arguments "$@"

    # Validate arguments
    validate_arguments

    # Show header
    echo -e "=== ${BLUE}Node Modules & Virtual Environment Cleaner${NC} ==="
    echo -e "Starting directory: $(get_relative_path "$START_DIR")"

    if [[ "$DRY_RUN" == "true" ]]; then
        echo -e "${YELLOW}DRY RUN MODE - No files will be deleted${NC}"
    fi

    if [[ "$BATCH_MODE" == "true" ]]; then
        echo -e "${YELLOW}BATCH MODE - No confirmation required${NC}"
    fi

    echo -e "Target directories: ${CUSTOM_DIRS[*]}"
    echo

    # Process each directory type
    for dir_name in "${CUSTOM_DIRS[@]}"; do
        if [[ "$BATCH_MODE" == "true" ]]; then
            remove_directories_batch "$dir_name"
        else
            remove_directories_interactive "$dir_name"
        fi
        echo
    done

    # Show final summary
    show_summary

    if [[ "$DRY_RUN" == "true" ]]; then
        print_success "Dry run completed! Use without --dry-run to actually delete files."
    else
        print_success "Script completed!"
    fi
}

# Run main function with all arguments
main "$@"
